# 面试题
## 线程池相关
**线程的同步机制有哪些？**

1. 互斥锁
2. 读写锁
3. 条件变量
4. 信号量
5. 原子操作 ,`std::atomic`,通过硬件支持，保证某些简单操作的原子性

**线程池中的工作线程是一直等待吗？**

是的，如果请求队列中没有任务，工作线程会阻塞在条件变量上；如果互斥锁被别的线程持有，工作线程会阻塞在互斥锁上。

**你的线程池工作线程处理完一个任务后的状态是什么？**

处理完后会继续尝试从请求队列中拿任务

**如果同时1000个客户端进行访问请求，线程数不多，怎么能及时响应处理每一个呢？**

本项目实现的是半同步半反应堆模式，异步线程只有一个，由主线程充当，负责监听所有的socket事件，如果是连接请求，就将其注册到epoll中；如果是读写请求，就将其插入到请求队列，由工作线程进行处理。这种方式的缺点是：1.工作线程和主线程共享请求队列，每次都要堆请求队列枷锁保护，白白耗费CPU时间。2.每个工作线程只能同时处理一个客户请求，如果客户数量较多，而工作线程较少，则请求队列中会堆积很多任务对象。

所以可以用另一种更高效的半同步/半异步模式，每个工作线程能同时处理多个客户端连接。主线程只管监听socket，主线程就接收新socket，并把它派发给工作线程。派发的方式可以通过管道来实现

**如果一个客户请求需要占用线程很久的时间，会不会影响接下来的客户请求呢，有什么好的策略呢?**

会影响，本项目使用的是线程池，线程数量有限，当工作线程都在工作时，进入请求队列，会增加响应时间，可能造成请求队列满而被丢弃。策略：1.调整线程池设计，一个线程池负责短作业，一个线程池负责长作业。2.动态调整线程池的大小。3.分布式任务队列（Kafka）